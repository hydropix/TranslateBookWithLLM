# GitHub Actions workflow for building Windows installer
# Triggers on release creation or manual dispatch

name: Build Windows Installer

on:
  release:
    types: [created]
  workflow_dispatch:
    inputs:
      version:
        description: 'Version number (e.g., 1.0.0)'
        required: false
        default: 'dev'

env:
  PYTHON_VERSION: '3.11'

jobs:
  build:
    runs-on: windows-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          cache: 'pip'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pyinstaller

      - name: Get version
        id: version
        shell: bash
        run: |
          if [ "${{ github.event_name }}" == "release" ]; then
            VERSION="${{ github.event.release.tag_name }}"
            # Remove 'v' prefix if present
            VERSION="${VERSION#v}"
          else
            VERSION="${{ github.event.inputs.version }}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Version: $VERSION"

      - name: Create version info file
        shell: python
        run: |
          version = "${{ steps.version.outputs.version }}"
          if version == "dev":
              version = "0.0.0"

          # Parse version
          parts = version.split('.')
          while len(parts) < 4:
              parts.append('0')
          major, minor, patch, build = [int(p) if p.isdigit() else 0 for p in parts[:4]]

          version_info = f'''# UTF-8
          VSVersionInfo(
            ffi=FixedFileInfo(
              filevers=({major}, {minor}, {patch}, {build}),
              prodvers=({major}, {minor}, {patch}, {build}),
              mask=0x3f,
              flags=0x0,
              OS=0x40004,
              fileType=0x1,
              subtype=0x0,
              date=(0, 0)
            ),
            kids=[
              StringFileInfo(
                [
                  StringTable(
                    '040904B0',
                    [
                      StringStruct('CompanyName', 'TranslateBookWithLLM'),
                      StringStruct('FileDescription', 'LLM-powered Book Translation Tool'),
                      StringStruct('FileVersion', '{version}'),
                      StringStruct('InternalName', 'TranslateBookWithLLM'),
                      StringStruct('LegalCopyright', 'MIT License'),
                      StringStruct('OriginalFilename', 'TranslateBookWithLLM.exe'),
                      StringStruct('ProductName', 'TranslateBookWithLLM'),
                      StringStruct('ProductVersion', '{version}')
                    ]
                  )
                ]
              ),
              VarFileInfo([VarStruct('Translation', [1033, 1200])])
            ]
          )
          '''

          with open('version_info.txt', 'w') as f:
              f.write(version_info)
          print(f"Created version_info.txt for version {version}")

      - name: Create favicon.ico from SVG
        shell: python
        run: |
          # Create a simple ICO file if SVG exists but ICO doesn't
          import os
          ico_path = 'src/web/static/favicon.ico'
          svg_path = 'src/web/static/favicon.svg'

          if not os.path.exists(ico_path):
              # Create a minimal valid ICO file (16x16 blank)
              # This is a placeholder - ideally convert from SVG
              ico_data = bytes([
                  0, 0,           # Reserved
                  1, 0,           # Type (1 = ICO)
                  1, 0,           # Number of images
                  16, 16,         # Width, Height
                  0,              # Color palette
                  0,              # Reserved
                  1, 0,           # Color planes
                  32, 0,          # Bits per pixel
                  40, 4, 0, 0,    # Size of image data
                  22, 0, 0, 0,    # Offset to image data
              ])
              # Add minimal BMP data for 16x16 32-bit image
              bmp_header = bytes([
                  40, 0, 0, 0,    # Header size
                  16, 0, 0, 0,    # Width
                  32, 0, 0, 0,    # Height (doubled for AND mask)
                  1, 0,           # Planes
                  32, 0,          # Bits per pixel
                  0, 0, 0, 0,     # Compression
                  0, 4, 0, 0,     # Image size
                  0, 0, 0, 0,     # X pixels per meter
                  0, 0, 0, 0,     # Y pixels per meter
                  0, 0, 0, 0,     # Colors used
                  0, 0, 0, 0,     # Important colors
              ])
              # Blue color pixels (16x16x4 bytes = 1024 bytes)
              pixels = bytes([66, 133, 244, 255] * 256)  # Google blue color
              # AND mask (16x16/8 = 32 bytes, but padded to 64)
              and_mask = bytes([0] * 64)

              with open(ico_path, 'wb') as f:
                  f.write(ico_data + bmp_header + pixels + and_mask)
              print(f"Created placeholder {ico_path}")
          else:
              print(f"{ico_path} already exists")

      - name: Build executable with PyInstaller
        run: |
          pyinstaller TranslateBookWithLLM.spec --clean --noconfirm

      - name: Verify build
        run: |
          if (Test-Path "dist\TranslateBookWithLLM.exe") {
            $size = (Get-Item "dist\TranslateBookWithLLM.exe").Length / 1MB
            Write-Host "Build successful! Executable size: $([math]::Round($size, 2)) MB"
            Get-Item "dist\TranslateBookWithLLM.exe"
          } else {
            Write-Error "Build failed - executable not found"
            exit 1
          }

      - name: Update Inno Setup version
        shell: python
        run: |
          version = "${{ steps.version.outputs.version }}"
          if version == "dev":
              version = "0.0.0-dev"

          with open('installer.iss', 'r', encoding='utf-8') as f:
              content = f.read()

          content = content.replace(
              '#define MyAppVersion "1.0.0"',
              f'#define MyAppVersion "{version}"'
          )

          with open('installer.iss', 'w', encoding='utf-8') as f:
              f.write(content)

          print(f"Updated installer.iss to version {version}")

      - name: Build installer with Inno Setup
        uses: Minionguyjpro/Inno-Setup-Action@v1.2.4
        with:
          path: installer.iss
          options: /O+

      - name: List output files
        run: |
          Write-Host "=== Installer Output ==="
          Get-ChildItem -Path "installer_output" -Recurse | Format-Table Name, Length, LastWriteTime

      - name: Upload installer artifact
        uses: actions/upload-artifact@v4
        with:
          name: TranslateBookWithLLM-Installer-${{ steps.version.outputs.version }}
          path: installer_output/*.exe
          retention-days: 30

      - name: Upload portable executable artifact
        uses: actions/upload-artifact@v4
        with:
          name: TranslateBookWithLLM-Portable-${{ steps.version.outputs.version }}
          path: dist/TranslateBookWithLLM.exe
          retention-days: 30

      # Upload to release if triggered by release event
      - name: Upload to Release
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v1
        with:
          files: |
            installer_output/*.exe
            dist/TranslateBookWithLLM.exe
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Optional: Build portable ZIP version
  build-portable:
    runs-on: windows-latest
    needs: build

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Get version
        id: version
        shell: bash
        run: |
          if [ "${{ github.event_name }}" == "release" ]; then
            VERSION="${{ github.event.release.tag_name }}"
            VERSION="${VERSION#v}"
          else
            VERSION="${{ github.event.inputs.version }}"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Download portable executable
        uses: actions/download-artifact@v4
        with:
          name: TranslateBookWithLLM-Portable-${{ steps.version.outputs.version }}
          path: portable

      - name: Create portable package
        run: |
          mkdir portable-package

          # Copy executable
          Copy-Item "portable\TranslateBookWithLLM.exe" "portable-package\"

          # Copy configuration
          Copy-Item ".env.example" "portable-package\.env.example"
          Copy-Item ".env.example" "portable-package\.env"

          # Copy optional docs if they exist
          if (Test-Path "README.md") { Copy-Item "README.md" "portable-package\" }
          if (Test-Path "LICENSE") { Copy-Item "LICENSE" "portable-package\" }
          if (Test-Path "SIMPLE_MODE_README.md") { Copy-Item "SIMPLE_MODE_README.md" "portable-package\" }
          if (Test-Path "TRANSLATION_SIGNATURE.md") { Copy-Item "TRANSLATION_SIGNATURE.md" "portable-package\" }

          # Create output directory
          New-Item -ItemType Directory -Path "portable-package\translated_files" -Force

          # Create ZIP
          Compress-Archive -Path "portable-package\*" -DestinationPath "TranslateBookWithLLM-Portable-${{ steps.version.outputs.version }}.zip"

      - name: Upload portable ZIP artifact
        uses: actions/upload-artifact@v4
        with:
          name: TranslateBookWithLLM-Portable-ZIP-${{ steps.version.outputs.version }}
          path: TranslateBookWithLLM-Portable-*.zip
          retention-days: 30

      - name: Upload portable ZIP to Release
        if: github.event_name == 'release'
        uses: softprops/action-gh-release@v1
        with:
          files: TranslateBookWithLLM-Portable-*.zip
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
